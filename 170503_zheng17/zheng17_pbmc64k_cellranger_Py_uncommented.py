
# coding: utf-8

# ### Scanpy benchmark for Zheng *et al.*, Nat. Comm. (2017)

# This is the Scanpy benchmark for the *Cell Ranger* R script of Zheng *et al.*, Nat. Comm. (2017) available from https://github.com/10XGenomics/single-cell-3prime-paper.

# In[10]:

#%config InlineBackend.figure_formats = ['retina']  # increase resolution on retina screens
import numpy as np
import scanpy as sc

sc.sett.verbosity = 1                # show some output
sc.sett.set_dpi(70)                  # low pixel number yields small inline figures
sc.sett.file_format_figures = 'png'  # set this to 'svg' (notebook) or 'pdf' (files) if you want vector graphics
sc.sett.savefigs = False             # set to True if you want to save figures to `./figs/`


# Some benchmark settings.

# In[11]:

# only use the first n cells, set to 0 if you want all cells
use_first_n_cells = 5000
# show initial usage of memory
sc.utils.print_memory_usage()


# In[12]:

filename_data = './data/storage/icbTTTdata/lukas.simon/projects/ImputeGeneExpression/data/10xGenomics/pbmc68k/filtered_matrices_mex/hg19/matrix.mtx'


# Load the data. This takes a long time only when first reading the row data from the `.mtx` text file. It's very fast the second time.

# In[13]:

#%%time
adata = sc.read(filename_data).transpose()
adata = adata[:use_first_n_cells-1] if use_first_n_cells != 0 else adata
sc.utils.print_memory_usage()


# Per-cell normalize the data matrix $X$ and identify highly-variable genes. Both are functions in Scanpy's preprocessing module [`high_var_genes_zheng17()`](https://github.com/theislab/scanpy/blob/6cbc9266e6b3e22a422b478bfddf0be79fcd7c5d/scanpy/preprocess/simple.py#L39) and [`smp_norm()`](https://github.com/theislab/scanpy/blob/6cbc9266e6b3e22a422b478bfddf0be79fcd7c5d/scanpy/preprocess/simple.py#L181).

# In[14]:

#%%time
sc.pp.filter_genes(adata, min_counts=1)  # only consider genes with more than 1 count
sc.pp.normalize_per_cell(adata)  # normalize with total UMI count per cell
sc.pp.filter_genes_dispersion(adata, log=False, n_top_genes=1000, plot=True)  # extract highly-variable genes
sc.utils.print_memory_usage()


# Perform PCA without zero-centering in order to not destroy sparsity.

# In[15]:

#%%time
sc.pp.log1p(adata)  # log transform: X = log(X + 1)
sc.tl.pca(adata, n_comps=50)
sc.utils.print_memory_usage()


# In[16]:

#%%time
# sc.tl.tsne(adata)
# sc.utils.print_memory_usage()


# In[17]:

#%%time
sc.tl.diffmap(adata)
sc.utils.print_memory_usage()


# Let us use the cell type labels generated by Zheng *et al.* by correlating gene expression with purified bulk data.

# In[19]:

filename_labels = './data/storage/icbTTTdata/lukas.simon/DropFilesHere/PBMC68k.cellLables.txt'
cell_labels = np.genfromtxt(filename_labels, delimiter='\t', dtype=str)
# add it as sample annotation
adata.smp['cell_labels'] = cell_labels[:adata.X.shape[0]]


# If not setting the parameter `n_cpus` in `sc.tsne()`, a slower tSNE implementation is used (the one of `scitkit-learn`). Results will differ from the above call.

# In[21]:

# plot the PCA and tSNE representation
sc.pl.pca(adata, smp='cell_labels')


# In[ ]:

sc.pl.tsne(adata, smp='cell_labels')
sc.pl.diffmap(adata, smp='cell_labels')


# In[ ]:



